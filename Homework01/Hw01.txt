1.
Using another programming language, do a function whereby it returns the sum of all squares of even numbers
//The code below is written in Kotlin

fun sumOfEvenSquares(data: Array<Int>): Int {

    var sum = 0
    //so when it is even number, square that number and add it to the sum
    for (item in data.indices) {
        if (item % 2 == 0) {
            sum += item * item
        }
    }
    return sum
}


2. 
Describe in your own words each of these major theories of computations

// 
Language Theory -> It focuses on how to convey information and computations by analysing usable data to be shown as a string of symbols, 
by giving eaach of these symbols meaning.

Automata Theory -> The study of how machines solve problems and carry out their jobs
so that we are able to build effective functions that are computable.

Computability Theory -> Although many problems have been solved using different models of computation,
the ability of computers to do such tasks are not limitless as this remains an active field of study.

Complexity Theory -> This concerns with how much resources (mostly the number of steps, time and memory) each problem or task require to complete.


3.
Using Lisp, Python, JavaScript, Java, Ruby, Clojure, and Swift, write lambda functions that cube a number

//Lisp
(write ((lambda (value )
   (* value value value))
   ;pass the values
   23 )

//Python
cubed_num = lambda x: (x*x*x, num)

//JavaScript
let cubeNumber = (value) => value ** 3;

//Ruby
cubedNumber = lambda { |num| num ** 3 }

//Clojure
(fn  [number]  (number * number * number) )

//Swift
var cubeNumber = { (num: Int) -> (Int) in
  return num * num * num
}


4.
Indicate if each of these is true or false

∅∈∅                     --> True
∅∈{∅}                   --> True
∅⊆∅                      --> True
∅⊆{∅}                    --> True
{x,y}⊆P({x,y,{x,y}})     --> True
P(∅)={∅}                 --> True
{x,y,z}3−{s∣|s|≤3}≠∅    --> 
⋃{N,B,Q}−B=Q             --> False
(9,3,F)∈Z×B×R∧(1,2)↓1=2 --> 
|P({a,b,c})−P({a,b})|=5   --> False


5.
Is the intersection of two partial orders a partial order? If so, prove it. If not, give a counterexample.

ANSWER: We feel that there's not a straight answer in this case as it depends on the elements or variables we are comparing. With that said, if we are comparing 2 variables (antisymmetric a >= b, b >= a SO a == b) then they are a partial order. However, when the two elements are incomparable (Boolean / Integer), then it is not a partial order.

credits: https://cglab.ca/~discmath/relations-types.html

6.
Reduce each of these expressions

a. f5(20)                              --> f(f(f(f(f(20)))))  --> 671
b. f∘f                                 --> f^2
c. g(f[5/3](3)−f[5/3](2))              --> λx. λy. 3*x*y      --> 45
d. (λw.(f−1(71),w(5),w(1)))(f∘(g1))    --> 
e. (λx.(xx))(λx.(xx))                  --> λx. (xx)^

7.
a. 3↑↑2    -->  27
b. 2↑↑↑3   -->  2 ↑↑ 2 ↑↑ 2 --> 8↑↑2 --> 512
c. 7909128533892359mod90277 --> 45654
d. (3+2i−8k)×(8i+2j−k)      --> 
e. log82333333333           --> 10.9155756985

8. 
Translate the following sentences into logical notation

a. If you don't leave now, you will not win the prize.
    if (l.Now) then p¬F))

b. Ani or her sisters might have been late.
    ◊ (L(a) ∨ (∀p. Sap ⊃ Lp))

c. Some dogs like cats who live in the capital of Turkey.
    ∃ c⊆t.(◊d. l(c))

d. The person who won the race prefers orange juice to tea.
    |p -> r| E(To¬t)

e. 3 will never be greater be 7.
    G(¬(3>7)
    
f. Not every odd number is greater than its own square.
    G(◊¬ n > n^2)
    
g. Something evil caused all evil things except itself.
    E(◊e → □e ¬ i)
    
h. Some day, it will be possible that all players will have the same score.
    F( pr(□p ∧ s)
    
i. War is peace, freedom is slavery, and ignorance is strength.
    w = p, f = sl, i = st
    
j. All that was once true will someday necessarily be forever false.
    P(T) -> F(F)
    
9.
(¬F(P)) ≡ (G(¬p))
They are duals of each other because G states that some phenomenon will always be true, and since that's the case ten in the future (G) will also have such events.

10. 
Formula is not provable --> Arrays in programming language such as Java, has constant time look up, so we should always use arrays. This is consistent but incomplete because, even though the chances are low, if new technology emerges, and arrayList can perform as well as arrays then the latter would be deprecated.
